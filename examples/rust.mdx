---
title: "Rust Example"
description: "Example Rust repo using repo-owned docker-compose.preview.yml for preview-deployer"
---

This example uses **no built-in Rust template**. The orchestrator uses a **repo-owned** `docker-compose.preview.yml` (or `docker-compose.preview.yaml`) in the repository root and injects host ports for the app and db.

## Repository

- **Repo**: [rust-project-preview-example](https://github.com/your-org/rust-project-preview-example) — replace with your repo URL when published.

## Stack

- **Framework**: Rust (Axum or similar)
- **Database**: PostgreSQL (migrations on startup)
- **Cache**: Redis
- **Config**: `.env` (`DATABASE_URL`, `REDIS_URL`)
- **Health**: `GET /health`, `GET /ready` (DB + Redis), `GET /ping`, `GET /stats`
- **Migrations and seeder**: Run on app startup

## Key files

### `docker-compose.preview.yml` (repository root) — required

For Rust there is no built-in template, so you must provide a preview compose file. Use service names `app` and `db`; do **not** set host ports—the orchestrator injects them.

Example structure (adjust build and env to match your repo):

```yaml
services:
  app:
    build: .
    ports: []   # Orchestrator injects host port
    environment:
      - DATABASE_URL=postgres://preview:preview@db:5432/pr_${PR_NUMBER}
      - REDIS_URL=redis://redis:6379/
    depends_on:
      - db
      - redis
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: preview
      POSTGRES_PASSWORD: preview
      POSTGRES_DB: pr_${PR_NUMBER}
  redis:
    image: redis:7-alpine
```

The orchestrator writes `docker-compose.preview.generated.yml` with injected ports and runs `docker compose` against it.

### `preview-config.yml` (repository root) — required

You must add `preview-config.yml` with all required fields. Set `framework: rust` so the orchestrator knows the app port and entrypoint; when you provide `docker-compose.preview.yml`, the orchestrator still uses it for compose and uses `preview-config.yml` for validation, health check path, and optional build/startup commands.

```yaml
framework: rust
database: postgres
health_check_path: /health
app_port: 8080
app_port_env: PORT
app_entrypoint: ./app
# Or ./target/release/app for release builds
# Optional:
# build_commands:
#   - cp .env.example .env
# env:
#   - RUST_LOG=info
```

## Local run and API

See the repo README for:

- `cp .env.example .env`, set `DATABASE_URL` and `REDIS_URL`
- `createdb preview_example`, `cargo run`
- App listens on `http://0.0.0.0:8080`

Endpoints: `/health`, `/ready`, `/ping`, `/stats`. Port and routing are handled by the orchestrator when using the injected compose.
